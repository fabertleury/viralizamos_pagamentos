generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Estrutura da tabela payment_request existente no banco de dados
model PaymentRequest {
  id                     String                @id @default(uuid())
  token                  String                @unique
  amount                 Float
  service_id             String?
  profile_username       String?
  customer_email         String
  customer_name          String
  customer_phone         String?
  service_name           String?
  return_url             String?
  status                 String                @default("pending")
  processed_payment_id   String?
  additional_data        String?
  created_at             DateTime              @default(now())
  expires_at             DateTime?
  processed_at           DateTime?
  external_service_id    String?
  processingQueue        ProcessingQueue[]
  provider_response_logs ProviderResponseLog[]
  transactions           Transaction[]

  @@index([token])
  @@index([status])
  @@index([service_id])
  @@index([external_service_id])
  @@index([created_at])
  @@map("payment_requests")
}

model Transaction {
  id                     String                     @id @default(uuid())
  payment_request_id     String
  external_id            String?
  status                 String
  method                 String
  amount                 Float
  provider               String
  pix_code               String?
  pix_qrcode             String?
  metadata               String?
  created_at             DateTime                   @default(now())
  updated_at             DateTime                   @updatedAt
  processed_at           DateTime?
  notification_logs      PaymentNotificationLog[]
  processing_failures    PaymentProcessingFailure[]
  provider_response_logs ProviderResponseLog[]
  payment_request        PaymentRequest             @relation(fields: [payment_request_id], references: [id])
  webhook_logs           WebhookLog[]

  @@index([payment_request_id])
  @@index([external_id])
  @@index([provider])
  @@index([status])
  @@index([created_at])
  @@map("transactions")
}

model PaymentIdempotencyLog {
  id         String   @id @default(uuid())
  key        String   @unique
  response   String
  created_at DateTime @default(now())

  @@index([key])
  @@index([created_at])
  @@map("payment_idempotency_log")
}

model PaymentProcessingFailure {
  id             String      @id @default(uuid())
  transaction_id String
  error_code     String
  error_message  String
  stack_trace    String?
  metadata       String?
  created_at     DateTime    @default(now())
  transaction    Transaction @relation(fields: [transaction_id], references: [id])

  @@index([transaction_id])
  @@index([error_code])
  @@index([created_at])
  @@map("payment_processing_failures")
}

model ProcessingQueue {
  id                 String         @id @default(uuid())
  payment_request_id String
  status             String
  type               String
  priority           Int            @default(0)
  attempts           Int            @default(0)
  max_attempts       Int            @default(3)
  last_error         String?
  metadata           String?
  created_at         DateTime       @default(now())
  updated_at         DateTime       @updatedAt
  processed_at       DateTime?
  next_attempt_at    DateTime?
  payment_request    PaymentRequest @relation(fields: [payment_request_id], references: [id])

  @@index([payment_request_id])
  @@index([status])
  @@index([type])
  @@index([priority])
  @@index([next_attempt_at])
  @@map("processing_queue")
}

model User {
  id         String    @id @default(uuid())
  email      String    @unique
  name       String
  role       String    @default("user")
  phone      String?
  last_login DateTime?
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt

  @@index([email])
  @@index([role])
  @@map("users")
}

model WebhookLog {
  id             String       @id @default(uuid())
  transaction_id String?
  type           String
  event          String
  data           String
  processed      Boolean      @default(false)
  error          String?
  created_at     DateTime     @default(now())
  transaction    Transaction? @relation(fields: [transaction_id], references: [id])

  @@index([transaction_id])
  @@index([type])
  @@index([event])
  @@index([processed])
  @@index([created_at])
  @@map("webhook_logs")
}

model PaymentNotificationLog {
  id             String      @id @default(uuid())
  transaction_id String
  type           String
  target_url     String?
  status         String
  error_message  String?
  error_stack    String?
  payload        String?
  response       String?
  created_at     DateTime    @default(now())
  transaction    Transaction @relation(fields: [transaction_id], references: [id])

  @@index([transaction_id])
  @@index([type])
  @@index([status])
  @@index([created_at])
  @@map("payment_notification_logs")
}

model ProviderResponseLog {
  id                 String         @id @default(uuid())
  transaction_id     String
  payment_request_id String
  provider_id        String
  service_id         String
  order_id           String
  post_id            String?
  post_code          String?
  response_data      String
  status             String
  created_at         DateTime       @default(now())
  payment_request    PaymentRequest @relation(fields: [payment_request_id], references: [id])
  transaction        Transaction    @relation(fields: [transaction_id], references: [id])

  @@index([transaction_id])
  @@index([payment_request_id])
  @@index([provider_id])
  @@index([service_id])
  @@index([order_id])
  @@index([status])
  @@index([created_at])
  @@map("provider_response_logs")
}

model BlockedEmail {
  id         String   @id @default(uuid())
  email      String   @unique
  reason     String?
  blocked_at DateTime @default(now())
  blocked_by String?

  @@index([email])
  @@map("blocked_emails")
}
